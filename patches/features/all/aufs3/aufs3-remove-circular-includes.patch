From: Ian Campbell <ijc@hellion.org.uk>
Date: Fri, 18 Jul 2014 22:12:19 +0100
Subject: aufs3: remove include of linux/fs.h from linux/mm.h
Forwarded: http://sourceforge.net/p/aufs/mailman/message/32626407/

This include is added by aufs3-mmap.patch but causes circular dependencies on
arm64 as seen with the Debian kernel packages in http://buildd.debian-ports.org/status/fetch.php?pkg=linux&arch=arm64&ver=3.14.12-1&stamp=1405234443 which contains:

In file included from /«PKGBUILDDIR»/include/linux/mm.h:23:0,
                 from /«PKGBUILDDIR»/include/linux/pid_namespace.h:6,
                 from /«PKGBUILDDIR»/include/linux/ptrace.h:9,
                 from /«PKGBUILDDIR»/arch/arm64/include/asm/compat.h:26,
                 from /«PKGBUILDDIR»/arch/arm64/include/asm/stat.h:23,
                 from /«PKGBUILDDIR»/include/linux/stat.h:5,
                 from /«PKGBUILDDIR»/include/linux/module.h:10,
                 from /«PKGBUILDDIR»/init/main.c:15:
/«PKGBUILDDIR»/include/linux/fs.h:1575:64: warning: 'struct kstat' declared inside parameter list [enabled by default]
  int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);

According to http://article.gmane.org/gmane.linux.ports.arm.kernel/342042
> The added mm.h->fs.h looks like a mistake, it should not be there, and we have
> in the past worked hard to separate mm.h, sched.h and fs.h from one another.

By turning the various additions to linux/mm.h into macros rather than static
inlines we can avoid the need for the additional includes. Convert all but the
vm?_pr_or_file functions which don't require additional includes and are a bit
trickier to turn into macros (due to having a return value).

Also take the opportunity to wrap the vmr_* macros in ifndef CONFIG_MMU

Signed-off-by: Ian Campbell <ijc@hellion.org.uk>

--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -18,9 +18,6 @@
 #include <linux/pfn.h>
 #include <linux/bit_spinlock.h>
 #include <linux/shrinker.h>
-#include <linux/dcache.h>
-#include <linux/file.h>
-#include <linux/fs.h>
 
 struct mempolicy;
 struct anon_vma;
@@ -1170,6 +1167,7 @@
 #endif
 }
 
+#ifndef CONFIG_MMU
 static inline struct file *vmr_do_pr_or_file(struct vm_region *region,
 					     const char func[], int line)
 {
@@ -1178,25 +1176,29 @@
 	return (f && pr) ? pr : f;
 }
 
-static inline void vmr_do_fput(struct vm_region *region,
-			       const char func[], int line)
-{
-	struct file *f = region->vm_file, *pr = region->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	fput(f);
-	if (f && pr)
-		fput(pr);
-}
+#define vmr_pr_or_file(region)		vmr_do_pr_or_file(region, __func__, \
+							  __LINE__)
 
-static inline void vma_do_file_update_time(struct vm_area_struct *vma,
-					   const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	file_update_time(f);
-	if (f && pr)
-		file_update_time(pr);
-}
+#define vmr_fput(region) do {						\
+	struct vm_region *_region = (region);				\
+	struct file *f = _region->vm_file, *pr = _region->vm_prfile;	\
+	aufs_trace(f, pr, __func__, __LINE__, "vmr_fput");		\
+	fput(f);							\
+	if (f && pr)							\
+		fput(pr);						\
+} while(0);
+
+#endif
+
+#define vma_file_update_time(vma) {				\
+	struct vm_area_struct *_vma = (vma);			\
+	struct file *f = _vma->vm_file, *pr = _vma->vm_prfile;	\
+	aufs_trace(f, pr, __func__, __LINE__,			\
+		   "vma_file_update_time");			\
+	file_update_time(f);					\
+	if (f && pr)						\
+		file_update_time(pr);				\
+} while (0)
 
 static inline struct file *vma_do_pr_or_file(struct vm_area_struct *vma,
 					     const char func[], int line)
@@ -1206,35 +1208,26 @@
 	return (f && pr) ? pr : f;
 }
 
-static inline void vma_do_get_file(struct vm_area_struct *vma,
-				   const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	get_file(f);
-	if (f && pr)
-		get_file(pr);
-}
+#define vma_pr_or_file(vma)	    vma_do_pr_or_file(vma, __func__, \
+							 __LINE__)
 
-static inline void vma_do_fput(struct vm_area_struct *vma,
-			       const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	fput(f);
-	if (f && pr)
-		fput(pr);
-}
-
-#define vmr_pr_or_file(region)		vmr_do_pr_or_file(region, __func__, \
-							  __LINE__)
-#define vmr_fput(region)		vmr_do_fput(region, __func__, __LINE__)
-#define vma_file_update_time(vma)	vma_do_file_update_time(vma, __func__, \
-								__LINE__)
-#define vma_pr_or_file(vma)		vma_do_pr_or_file(vma, __func__, \
-							  __LINE__)
-#define vma_get_file(vma)		vma_do_get_file(vma, __func__, __LINE__)
-#define vma_fput(vma)			vma_do_fput(vma, __func__, __LINE__)
+#define vma_get_file(vma) do {					\
+	struct vm_area_struct *_vma = (vma);			\
+	struct file *f = _vma->vm_file, *pr = _vma->vm_prfile;	\
+	aufs_trace(f, pr, __func__, __LINE__, "vma_get_file");	\
+	get_file(f);						\
+	if (f && pr)						\
+		get_file(pr);					\
+} while(0)
+
+#define vma_fput(vma) do {					\
+	struct vm_area_struct *_vma = (vma);			\
+	struct file *f = _vma->vm_file, *pr = _vma->vm_prfile;	\
+	aufs_trace(f, pr, __func__, __LINE__, "vma_fput");	\
+	fput(f);						\
+	if (f && pr)						\
+		fput(pr);					\
+} while(0)
 
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
